# Hardware tests

## Memory expansion test

In the file `test_ramexp.asm` you will find a small assembly program that tests the presence of the 256K RAM expansion. You can
build the program with `make ram_exp` which results in the binary `ram_exp.bin`. This can then be run as described above.

The program simply writes a byte to memory at 6502 address `$6100` then maps in a page of expanded RAM and writes a different 
value to the same 6502 address. Then the values are read again and checked.

## SID test

The file `testsid.bas` contains a `superbasic` program can be used to test the SIDs As described in the `superbasic` manual the program 
can be stored on a comaptible SD card and loaded from there or it can be uploaded to the F256 Jr. through the following command:

`python3 fnxmgr.zip --port /dev/ttyUSB0 --binary testsid.bas --address 28000`

After the machine resets type `xload` and after that you can list and/or run the program. Please note that after a power on of the F256 Jr.
the first time you try to play a sound on either the left or the right SID does not work. This is probably specific to the Nano SwinSIDs in 
my board or to my speakers. The assembly version can be built with `make sid_test`. The relevant source files are `sid_test.asm` and 
`sid_only.asm`. 

## Joystick test

The file `joystick.asm` contains the source for an assembly program that visualizes the joystick state on the text screen. You can build
the program by issuing the command `make joystick`. Its target address is $4000. One thing that has to be mentioned is that the kernel
uses `yourEventBuffer.joystick.joy0` for the events generated by the joystick connected to the pin headers labelled `JOYSTICK1` on the 
F256 Jr. board. `yourEventBuffer.joystick.joy1` on the other hand must be used for a joystick connected to the pin headers labeled 
`JOYSTICK0`.

## SLIP networking

Unfortunately the documentation for this feature is too sketchy at the moment that I am not able to write an example proggram. My idea
is to use a Raspberry Pi as the other end of the SLIP connection which could the act as a "modem" for the F256 Jr. This in turn could
enable multiplayer games on the platform. Nontheless there is a skeleton `slip.asm` that can be built by `make slip`.

## Serial communication via the UART

The file `uart.asm` contains a little program that demonstrates the sending and receiving bytes via the F256 Jr. UART. It
can be built by `make uart`. The receiving side of the serial communication is implemented in python and can be found in the file 
`ser_echo.py`. In essence these files implement a simple echo server. The F256 sends a string and the python program returns that
string.

## Bitmap graphics

The files `hires.asm` and  `hires_base.asm` implement a simple demo that turns on graphics mode and draws a color gradient on the screen.
This program can be built by `make hires`. It has to be loaded to the address $4000 from where it also can be run.

## Cursor control

In `cursor.asm` a little example is given which demonstrates controlling the cursor position in machine language. On top of that it
prints all characters available in the font on the screen. This example can be built by running `make cursor`. The resulting program
has the usual target address of $4000 from where it can be started after an upload through `fnxmgr`.

## Text IO
In `txtio.asm` you will find routines which allow full control over the cursor as well as printing text on the screen relative to the
cursor positon and a robust string entry function. The program `test_txtio.asm` demonstrates these routines. It can be built using
`make txtio`. The target address of the resulting binary `txtio.bin` is as usual $4000.

## Mouse test

The file `mouse.asm` contains a program which visualizes the mouse messages the kernel sends when a mouse attached to the PS/2 port 
of the F256 K is moved or its buttons are clicked. It can be built by `make mouse` and its target address is also $4000 from where it
can be `call`ed in Basic. As the F256 Jr. uses the PS2/2 port for the keyboard, this program will only run on the F256 K. I have tried 
to use a USB mouse together with several USB to PS/2 adapters but none of the adapters has worked. Using a real PS/2 mouse worked.

The makefile generates the binary `mouse.bin` which can be executed from address $4000 after being loaded by `bload "mouse.bin", $4000`
from BASIC or after uploading via USB using the command

`python3 fnxmgr.zip --port /dev/ttyUSB0 --binary mouse.bin --address 4000`

## SNES game pad test   

The file `snes_pad.bin` demonstrates how to query an SNES game pad for the state of its buttons. In order to connect the gamepad 
to your F256 you need an adapter box, which also can be bought from  Foenix retro systems.

It has to be noted that on my F256 Jr. (using the firmware which was current in march 2023) the bit positions which represent the
buttons of the controller have to be rotated one position to the left in order to match the description in table 12.3 of the system
reference manual. On my F256 K the description in the manual did fit the observed behaviour. It is also worth mentioning that at 
least some modern replica controllers are not comaptible with the F256 machines and their adapter box. I have tried two different 
brands which did not work but an original controller worked.

As usual the target address of `snes_pad.bin` is $4000 and can be called from there after a transfer to the F256.