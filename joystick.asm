.include "api.asm"

; target address is $4000
* = $4000
.cpu "w65c02"

OUT_LINE = 29

.include "macros.asm"


; --------------------------------------------------
; This routine is the entry point of the program
;--------------------------------------------------
main
    jsr initEvents

    #kprint 0, OUT_LINE - 3, intro, len(intro), introColor
    #kprint 0, OUT_LINE - 1, txtLabel, len(txtLabel), dataColor
    #kprint 0, OUT_LINE, txtLabel2, len(txtLabel2), dataColor
    #kprint 0, OUT_LINE + 2, clearDone, len(clearDone), dataColor
    jsr trackJoystickEvents

    jsr restoreEvents
    rts

; value of event buffer at program start (likely set by `superbasic`)
oldEvent .byte 0, 0
; the new event buffer
myEvent .dstruct kernel.event.event_t

; --------------------------------------------------
; This routine saves the current value of the pointer to the kernel event 
; buffer and sets that pointer to the address of myEvent. This in essence
; disconnects superbasic from the kernel event stream.
;--------------------------------------------------
initEvents
    #move16Bit kernel.args.events, oldEvent
    #load16BitImmediate myEvent, kernel.args.events
    rts


; --------------------------------------------------
; This routine restores the pointer to the kernel event buffer to the value
; encountered at program start. This reconnects superbasic to the kernel
; event stream.
;--------------------------------------------------
restoreEvents
    #move16Bit oldEvent, kernel.args.events
    rts


; --------------------------------------------------
; This routine polls the kernel event queue. It listens for JOYSTICK and key.PRESSED
; events. If a key press is received, the routine returns.
;--------------------------------------------------
trackJoystickEvents
    ; Peek at the queue to see if anything is pending
    lda kernel.args.events.pending ; Negated count
    bpl trackJoystickEvents
    ; Get the next event.
    jsr kernel.NextEvent
    bcs trackJoystickEvents
    ; Handle the event
    lda myEvent.type    
    
    cmp #kernel.event.JOYSTICK
    beq _found

    cmp #kernel.event.key.PRESSED
    beq _done

    bra trackJoystickEvents
_found
    jsr printState
    bra trackJoystickEvents
_done
    #kprint 0, OUT_LINE + 2, msgDone, len(msgDone), introColor
    rts    


joyData .byte 0
; --------------------------------------------------
; This routine processes joystick events received by the kernel. The event data 
; consists of a single byte that describes the state of the joystick switches.
;
; This routine visualizes each set bit in the event data by a "1" and a clear
; bit by "-".
;--------------------------------------------------
printState
    ; Change here to use other joystick port. BEWARE: myEvent.joystick.joy0
    ; contains the events generated by the joystick connected to the pin headers 
    ; labelled JOYSTICK1 on the F256 Jr. board. myEvent.joystick.joy1 on the other
    ; hand is generated by a joystick connected to the pin headers labeled 
    ; JOYSTICK0.
    lda myEvent.joystick.joy0
    sta joyData

    ldx #0
_loopBits
    lda joyData
    and #$80
    beq _zeroBit
    lda #$31
    sta byteData, x
    bra _nextLoop
_zeroBit
    lda #$2D
    sta byteData, x
_nextLoop
    asl joyData
    inx
    cpx #8
    bne _loopBits

    #kprint 0, OUT_LINE, byteData, len(byteData), dataColor
    rts


; Texts to display
byteData .text  "00000000"
; Fire, Right, Left, Down, Up: FRLDU
txtLabel .text  "   FRLDU"
txtLabel2 .text "--------"
msgDone .text   "Done"
clearDone .text "    "
dataColor .text x"62" x len(byteData)

intro .text "Move joystick. Press any key to stop."
introColor .text x"26" x len(intro)